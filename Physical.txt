รถ
/*
   Vehicle Robot (Receiver) - ESP32 Version
   Power: ESP32 Powered by 5V pin (from L298N)
*/
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

// --- ตั้งค่า NRF24L01 สำหรับ ESP32 ---
// CE = GPIO 4, CSN = GPIO 5
RF24 radio(4, 5); 
const byte address[6] = "00001";

// --- ตั้งค่าขา Motor Driver (L298N) ---
// ENA=13, IN1=12, IN2=14
// IN3=27, IN4=26, ENB=25
const int ENA = 13; 
const int IN1 = 12;
const int IN2 = 14;
const int IN3 = 27;
const int IN4 = 26;
const int ENB = 25; 

// ความเร็ว (ESP32 PWM ใช้ 0-255 ได้ผ่าน analogWrite ใน Arduino core รุ่นใหม่)
const int MOTOR_SPEED = 200; 

void setup() {
  Serial.begin(115200); // ESP32 นิยมใช้ 115200
  Serial.println("ESP32 Car Starting...");

  // Setup Motors
  pinMode(ENA, OUTPUT); pinMode(ENB, OUTPUT);
  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  
  stopMotors();

  // Setup Radio
  // ESP32 ใช้ VSPI อัตโนมัติ (SCK=18, MISO=19, MOSI=23)
  if (!radio.begin()) {
    Serial.println("NRF24 Hardware Error!");
    while(1);
  }
  radio.openReadingPipe(0, address);
  radio.setPALevel(RF24_PA_MAX);
  radio.startListening();
  
  Serial.println("Waiting for command...");
}

void loop() {
  if (radio.available()) {
    float distance = 0.0;
    radio.read(&distance, sizeof(float));
    
    Serial.print("Received: "); Serial.println(distance);
    
    // --- เงื่อนไขเดิม ---
    
    // 1. เลี้ยวซ้าย (4.5 - 5.5)
    if (distance >= 4.5 && distance <= 5.5) {
      Serial.println("Action: Turn Left");
      moveLeft();
      delay(1000); 
      stopMotors();
    }
    // 2. เดินหน้า (9.5 - 10.5)
    else if (distance >= 9.5 && distance <= 10.5) {
      Serial.println("Action: Forward");
      moveForward();
      delay(1000);
      stopMotors();
    }
    // 3. ถอยหลัง (14.5 - 15.5)
    else if (distance >= 14.5 && distance <= 15.5) {
      Serial.println("Action: Backward");
      moveBackward();
      delay(1000);
      stopMotors();
    }
    // 4. เลี้ยวขวา (19.5 - 20.5)
    else if (distance >= 19.5 && distance <= 20.5) {
      Serial.println("Action: Turn Right");
      moveRight();
      delay(1000);
      stopMotors();
    }
    else {
      stopMotors();
    }
  }
}

void moveForward() {
  analogWrite(ENA, MOTOR_SPEED);
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  analogWrite(ENB, MOTOR_SPEED);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}

void moveBackward() {
  analogWrite(ENA, MOTOR_SPEED);
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  analogWrite(ENB, MOTOR_SPEED);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
}

void moveLeft() {
  analogWrite(ENA, 0);
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  analogWrite(ENB, MOTOR_SPEED);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
}

void moveRight() {
  analogWrite(ENA, MOTOR_SPEED);
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  analogWrite(ENB, 0);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
}

void stopMotors() {
  digitalWrite(ENA, LOW); digitalWrite(ENB, LOW);
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
}


คุม
/*

 * Controller Robot (Sender)

 * ระบบ: UNO + NRF24 + HC-SR04 + Motor Turret + 4 Buttons

 */

#include <SPI.h>

#include <nRF24L01.h>

#include <RF24.h>



// --- ตั้งค่า NRF24L01 ---

RF24 radio(9, 10); // CE, CSN

const byte address[6] = "00001";



// --- ตั้งค่าขามอเตอร์ฐาน ---

const int TURRET_IN1 = 2;

const int TURRET_IN2 = 3;



// --- ตั้งค่าขา Sensor วัดระยะ ---

const int TRIG_PIN = 6;

const int ECHO_PIN = 7;



// --- ตั้งค่าขาปุ่มกด (Analog Pins ใช้เป็น Digital Input) ---

const int BTN_LEFT  = A0; // K1 หมุนซ้าย

const int BTN_SEND  = A1; // K2 วัดระยะและส่งค่า

const int BTN_RESET = A2; // K3 (เผื่อไว้)

const int BTN_RIGHT = A3; // K4 หมุนขวา



void setup() {

  Serial.begin(9600);

  

  // Setup Motor

  pinMode(TURRET_IN1, OUTPUT);

  pinMode(TURRET_IN2, OUTPUT);

  

  // Setup HC-SR04

  pinMode(TRIG_PIN, OUTPUT);

  pinMode(ECHO_PIN, INPUT);

  

  // Setup Buttons (INPUT_PULLUP: กด=LOW, ไม่กด=HIGH)

  pinMode(BTN_LEFT, INPUT_PULLUP);

  pinMode(BTN_SEND, INPUT_PULLUP);

  pinMode(BTN_RESET, INPUT_PULLUP);

  pinMode(BTN_RIGHT, INPUT_PULLUP);

  

  // Setup Radio

  if (!radio.begin()) {

    Serial.println("NRF24 Hardware Error!");

    while(1); // ค้างไว้ถ้า NRF เสีย

  }

  radio.openWritingPipe(address);

  radio.setPALevel(RF24_PA_MAX);

  radio.stopListening(); // โหมดส่ง

  

  Serial.println("Controller Ready...");

}



void loop() {

  // 1. ควบคุมการหมุน (กดแช่เพื่อหมุน)

  if (digitalRead(BTN_LEFT) == LOW) {

    digitalWrite(TURRET_IN1, HIGH);

    digitalWrite(TURRET_IN2, LOW);

  } 

  else if (digitalRead(BTN_RIGHT) == LOW) {

    digitalWrite(TURRET_IN1, LOW);

    digitalWrite(TURRET_IN2, HIGH);

  } 

  else {

    digitalWrite(TURRET_IN1, LOW);

    digitalWrite(TURRET_IN2, LOW);

  }



  // 2. กดปุ่ม K2 เพื่อวัดระยะและส่ง

  if (digitalRead(BTN_SEND) == LOW) {

    // วัดระยะ

    float distance = getDistance();

    

    Serial.print("Sending Distance: ");

    Serial.print(distance);

    Serial.println(" cm");

    

    // ส่งข้อมูล

    bool report = radio.write(&distance, sizeof(float));

    

    if (report) Serial.println("-> Send OK");

    else Serial.println("-> Send Fail");

    

    delay(500); // ดีเลย์ป้องกันกดรัว

  }

}



float getDistance() {

  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);

  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);

  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH);

  return duration * 0.034 / 2;

}




เทสSensor
/*
 * HC-SR04 Test Code
 * สำหรับทดสอบ Sensor วัดระยะ บนตัวคุม
 */

const int trigPin = 6; // ขา Trig
const int echoPin = 7; // ขา Echo

void setup() {
  Serial.begin(9600); // เปิด Serial Monitor ที่ความเร็ว 9600
  
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  
  Serial.println("--- Start Sensor Test ---");
}

void loop() {
  // 1. เคลียร์ขา Trig ให้เป็น LOW ก่อน
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);

  // 2. ยิงคลื่นเสียงออกไป (HIGH 10 ไมโครวินาที)
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  // 3. รอรับเสียงสะท้อนกลับ
  long duration = pulseIn(echoPin, HIGH);

  // 4. คำนวณระยะทาง (Sound speed = 0.034 cm/us)
  float distance = duration * 0.034 / 2;

  // 5. แสดงผลออกหน้าจอ
  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.println(" cm");

  delay(500); // หน่วงเวลา 0.5 วินาที เพื่อให้อ่านทัน
}
